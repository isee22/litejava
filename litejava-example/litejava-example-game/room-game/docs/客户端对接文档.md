# 客户端对接文档

本文档描述客户端如何与游戏服务端通信，适用于 Unity、Cocos、H5 等客户端开发。

## 1. 架构概览 (BabyKylin 模式)

```
┌─────────────┐     HTTP      ┌─────────────┐
│   Client    │ ────────────> │ HallServer  │
└─────────────┘               └─────────────┘
      │                              │
      │ WebSocket                    │ HTTP
      ▼                              ▼
┌─────────────┐               ┌─────────────┐
│ GameServer  │ <──────────── │AccountServer│
└─────────────┘   (注册/配置)  └─────────────┘
                                     │
                                     ▼
                               ┌─────────────┐
                               │    Redis    │
                               │ (用户缓存)   │
                               └─────────────┘
```

**核心原则：**
- 进入游戏前全部用 HTTP（登录、创建房间、加入房间）
- 进入游戏后用 WebSocket（实时游戏通信）
- 客户端直连 GameServer，无需 Gateway 代理
- 签名验证贯穿全流程
- **用户信息由服务端管理**：AccountServer 登录后缓存到 Redis (`player:{userId}`)，HallServer 从缓存读取，客户端无需传递

## 2. 服务端点

| 服务 | 端口 | 协议 | 说明 |
|------|------|------|------|
| Account Server | 8101 | HTTP | 登录/注册/玩家数据 |
| Hall Server | 8201 | HTTP | 房间创建/加入 |
| Game Server | 9100+ | WebSocket | 游戏实时通信 |

## 3. 完整流程

```
┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐
│  客户端  │      │ Account │      │  Redis  │      │  Hall   │      │  Game   │
└────┬────┘      └────┬────┘      └────┬────┘      └────┬────┘      └────┬────┘
     │                │                │                │                │
     │ 1. POST /login │                │                │                │
     │───────────────>│                │                │                │
     │                │ 2. 缓存用户信息  │                │                │
     │                │───────────────>│                │                │
     │   {userId, name, coins, roomId?}│                │                │
     │<───────────────│                │                │                │
     │                │                │                │                │
     │ 3. POST /quick_start {userId, gameType, roomLevel}               │
     │────────────────────────────────────────────────>│                │
     │                │                │ 4. 读取用户信息  │                │
     │                │                │<───────────────│                │
     │                │                │ 5. 选择/创建房间 │                │
     │                │                │ 6. 调用 GameServer               │
     │                │                │───────────────────────────────>│
     │   {roomId, token, time, sign, wsUrl}            │                │
     │<────────────────────────────────────────────────│                │
     │                │                │                │                │
     │ 7. WebSocket 连接 ws://wsUrl                                      │
     │─────────────────────────────────────────────────────────────────>│
     │ 8. LOGIN {token}                                                  │
     │─────────────────────────────────────────────────────────────────>│
     │   验证 token，进入房间                            │                │
     │<─────────────────────────────────────────────────────────────────│
```

**关键变化：**
- AccountServer 登录后将用户信息缓存到 Redis (`player:{userId}`)
- HallServer 从 Redis 读取用户信息，客户端只需传 `userId`
- 快速开始支持按 `roomLevel` (0=初级, 1=中级, 2=高级) 匹配房间

## 4. HTTP API

### 4.1 Account Server (8101)

#### 登录
```http
POST /login
Content-Type: application/json

{"username": "test", "password": "123456"}
```

**响应：**
```json
{
  "code": 0,
  "data": {
    "userId": 10001,
    "username": "test",
    "name": "玩家昵称",
    "coins": 10000,
    "roomId": "123456",    // 断线重连：如果在房间中则返回
    "serverId": "127.0.0.1:9100"
  }
}
```

#### 注册
```http
POST /register
Content-Type: application/json

{"username": "test", "password": "123456", "name": "玩家昵称"}
```

### 4.2 Hall Server (8201)

#### 快速开始（推荐，按等级匹配）
```http
POST /quick_start
Content-Type: application/json

{
  "userId": 10001,
  "gameType": "doudizhu",
  "roomLevel": 1
}
```

**参数说明：**
- `userId`: 用户ID（必填）
- `gameType`: 游戏类型（必填）
- `roomLevel`: 房间等级（必填）
  - 0 = 初级场
  - 1 = 中级场
  - 2 = 高级场

**响应：**
```json
{
  "code": 0,
  "data": {
    "roomId": "123456",
    "token": "eyJ...",
    "time": 1704067200000,
    "sign": "a1b2c3d4...",
    "wsUrl": "ws://127.0.0.1:9100/game"
  }
}
```

**说明：**
- 优先匹配相同等级的可用房间
- 如果没有可用房间，自动创建新房间
- 用户信息（name等）由服务端从 Redis 读取，无需客户端传递

#### 创建房间
```http
POST /create_room
Content-Type: application/json

{
  "userId": 10001,
  "gameType": "doudizhu"
}
```

**响应格式同快速开始**

#### 加入房间
```http
POST /enter_room
Content-Type: application/json

{
  "userId": 10002,
  "roomId": "123456"
}
```

**响应格式同快速开始**

### 4.3 游戏类型

| gameType | 说明 | 人数 |
|----------|------|------|
| doudizhu | 斗地主 | 3 |
| gobang | 五子棋 | 2 |
| mahjong | 麻将 | 4 |
| texas | 德州扑克 | 2-9 |
| niuniu | 牛牛 | 2-6 |

## 5. WebSocket 协议

### 5.1 连接地址
```
ws://{ip}:{port}/game

示例: ws://127.0.0.1:9100/game
```

### 5.2 消息格式

**请求：**
```json
{"cmd": 1, "data": {...}}
```

**成功响应：**
```json
{"cmd": 1, "code": 0, "data": {...}}
```

**错误响应：**
```json
{"cmd": 1, "errcode": 2, "errmsg": "sign check failed"}
```

### 5.3 登录 (cmd=1)

**请求：** 只需传递 token
```json
{
  "cmd": 1,
  "data": {
    "token": "eyJ..."
  }
}
```

**成功响应（首次进入）：**
```json
{
  "cmd": 1,
  "code": 0,
  "data": {
    "roomId": "123456",
    "ownerId": 10001,
    "seatIndex": 0,
    "seats": [
      {"seatIndex": 0, "userId": 10001, "name": "玩家1", "ready": false, "online": true},
      {"seatIndex": 1, "userId": 0, "name": "", "ready": false, "online": false}
    ],
    "game": null
  }
}
```

**成功响应（断线重连，包含游戏状态）：**
```json
{
  "cmd": 1,
  "code": 0,
  "data": {
    "roomId": "123456",
    "seatIndex": 0,
    "seats": [...],
    "game": {
      "gameStatus": 2,
      "currentSeat": 1,
      "landlordSeat": 0,
      "myCards": [3,4,5,6,7],
      "lastCards": [8,9,10],
      "bottomCards": [51,52,53]
    }
  }
}
```

**错误响应：**
```json
{"cmd": 1, "errcode": 1, "errmsg": "invalid token"}
{"cmd": 1, "errcode": 2, "errmsg": "room not found"}
```

### 5.4 心跳 (cmd=4)
```json
// 请求
{"cmd": 4}

// 响应
{"cmd": 4, "code": 0}
```

建议每 30 秒发送一次心跳。

### 5.5 准备 (cmd=504)
```json
// 请求
{"cmd": 504}

// 响应 (广播给房间所有人)
{"cmd": 504, "code": 0, "data": {"userId": 10001, "seatIndex": 0, "ready": true}}
```

### 5.6 退出房间 (cmd=106)
```json
// 请求
{"cmd": 106}

// 响应
{"cmd": 106, "code": 0}
```

## 6. 命令号速查

| 范围 | 说明 |
|------|------|
| 1-99 | 系统命令 (登录/心跳) |
| 100-499 | 房间/聊天 |
| 500-599 | 游戏通用命令 |
| 1000+ | 游戏特有命令 |

### 完整命令号表

| cmd | 名称 | 方向 | 说明 |
|-----|------|------|------|
| 1 | LOGIN | C↔S | 登录 (token+roomid+time+sign) |
| 4 | PING | C↔S | 心跳 |
| 106 | ROOM_EXIT | C→S | 退出房间 |
| 150 | CHAT_SEND | C→S | 发送聊天 |
| 151 | CHAT_MSG | S→C | 聊天消息 |
| 500 | USER_JOIN | S→C | 有人加入 |
| 501 | USER_EXIT | S→C | 有人退出 |
| 502 | USER_STATE | S→C | 状态变化 (上线/离线/托管) |
| 504 | READY | C↔S | 准备 |
| 505 | CANCEL_READY | C→S | 取消准备 |
| 510 | GAME_START | S→C | 游戏开始 |
| 511 | GAME_OVER | S→C | 游戏结束 |
| 520 | DEAL | S→C | 发牌 |
| 522 | TURN | S→C | 轮到谁 |

## 7. 断线重连

### 流程
1. 客户端登录 AccountServer 时，检查响应中的 `roomId` 字段
2. 如果 `roomId` 不为空，说明玩家在房间中，需要重连
3. 调用 HallServer `/enter_room` 重新获取 token
4. WebSocket 连接后，LOGIN 响应会包含完整游戏状态（`game` 对象）

```javascript
// 登录后检查断线重连
const loginResp = await login(username, password)
if (loginResp.data.roomId) {
  // 需要重连
  const reconnectResp = await enterRoom(loginResp.data.userId, loginResp.data.roomId)
  await connectGame(reconnectResp.data)
  // LOGIN 响应会包含 game 对象，恢复游戏状态
}
```

### 游戏状态恢复

LOGIN 响应中的 `game` 对象包含完整游戏状态：

```json
{
  "cmd": 1,
  "code": 0,
  "data": {
    "roomId": "123456",
    "seatIndex": 0,
    "seats": [...],
    "game": {
      "gameStatus": 2,           // 游戏阶段
      "currentSeat": 1,          // 当前操作玩家
      "landlordSeat": 0,         // 地主座位
      "myCards": [3,4,5,6,7],    // 我的手牌
      "lastCards": [8,9,10],     // 上家出的牌
      "bottomCards": [51,52,53]  // 底牌（地主可见）
    }
  }
}
```

客户端需要根据 `game` 对象恢复：
- 游戏阶段（叫地主/出牌）
- 当前操作玩家
- 地主标识
- 手牌显示
- 上家出牌
- 底牌显示（地主）

## 8. 示例代码

### JavaScript (H5)
```javascript
class GameClient {
  constructor() {
    this.ws = null
    this.userId = null
  }
  
  // 1. HTTP 登录
  async login(username, password) {
    const resp = await fetch('http://localhost:8101/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    })
    const result = await resp.json()
    if (result.code === 0) {
      this.userId = result.data.userId
      // 检查断线重连
      if (result.data.roomId) {
        return { needReconnect: true, ...result }
      }
    }
    return result
  }
  
  // 2. HTTP 快速开始（按等级匹配）
  async quickStart(gameType, roomLevel) {
    const resp = await fetch('http://localhost:8201/quick_start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: this.userId, gameType, roomLevel })
    })
    return resp.json()
  }
  
  // 3. HTTP 创建房间
  async createRoom(gameType) {
    const resp = await fetch('http://localhost:8201/create_room', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: this.userId, gameType })
    })
    return resp.json()
  }
  
  // 4. HTTP 加入房间
  async enterRoom(roomId) {
    const resp = await fetch('http://localhost:8201/enter_room', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: this.userId, roomId })
    })
    return resp.json()
  }
  
  // 5. WebSocket 连接游戏
  async connectGame({ wsUrl, token }) {
    this.ws = new WebSocket(wsUrl)
    
    return new Promise((resolve, reject) => {
      this.ws.onopen = () => {
        // 发送登录
        this.send(1, { token })
      }
      
      this.ws.onmessage = (e) => {
        const msg = JSON.parse(e.data)
        if (msg.cmd === 1) {
          if (msg.code === 0) {
            // 检查是否有游戏状态（断线重连）
            if (msg.data.game) {
              console.log('恢复游戏状态:', msg.data.game)
            }
            resolve(msg.data)
          } else {
            reject(new Error(msg.errmsg || '登录失败'))
          }
        }
        this.onMessage(msg)
      }
      
      this.ws.onerror = reject
    })
  }
  
  // 准备
  ready() {
    this.send(504, {})
  }
  
  // 发送消息
  send(cmd, data) {
    this.ws.send(JSON.stringify({ cmd, data }))
  }
  
  // 心跳
  startHeartbeat() {
    setInterval(() => this.send(4, {}), 30000)
  }
  
  // 处理消息
  onMessage(msg) {
    switch (msg.cmd) {
      case 504: console.log('准备状态:', msg.data); break
      case 510: console.log('游戏开始'); break
      case 511: console.log('游戏结束:', msg.data); break
      case 520: console.log('发牌:', msg.data); break
      case 522: console.log('轮到:', msg.data); break
    }
  }
}

// 使用示例
const client = new GameClient()

// 登录
const loginResult = await client.login('test', '123456')

// 检查断线重连
if (loginResult.data.roomId) {
  const reconnectResult = await client.enterRoom(loginResult.data.roomId)
  await client.connectGame(reconnectResult.data)
  client.startHeartbeat()
  // 游戏状态已自动恢复，无需准备
} else {
  // 快速开始（按等级匹配）
  const roomResult = await client.quickStart('doudizhu', 1)  // 1=中级场
  if (roomResult.code === 0) {
    await client.connectGame(roomResult.data)
    client.startHeartbeat()
    client.ready()
  }
}
```

## 9. 游戏协议文档

各游戏的详细协议参见：
- [斗地主协议](./game/斗地主协议.md)
- [五子棋协议](./game/五子棋协议.md)
- [麻将协议](./game/麻将协议.md)
- [德州扑克协议](./game/德州扑克协议.md)
- [牛牛协议](./game/牛牛协议.md)
