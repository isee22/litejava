# 故障排查指南

## 常见问题速查

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| WebSocket 连接失败 | 端口错误、服务未启动 | 检查端口、查看服务日志 |
| Token 无效 | Token 过期、格式错误 | 重新获取 token |
| 房间不存在 | 房间已销毁、roomId 错误 | 检查 roomId、重新匹配 |
| 匹配超时 | 玩家不足、服务器负载高 | 增加超时时间、检查服务器 |
| 断线重连失败 | 快照过期、服务器重启 | 返回大厅重新匹配 |
| 游戏操作无响应 | 不是你的回合、网络延迟 | 检查 TURN 消息、查看网络 |

## 1. 连接问题

### 1.1 WebSocket 连接失败

**症状：**
```javascript
WebSocket connection to 'ws://127.0.0.1:9100/game' failed
```

**排查步骤：**

1. **检查服务是否启动**
```bash
# Windows
netstat -ano | findstr 9100

# Linux/Mac
lsof -i :9100
```

2. **检查端口配置**
```yaml
# config.yml
server:
  wsPort: 9100  # 确认端口正确
```

3. **检查防火墙**
```bash
# Windows
netsh advfirewall firewall add rule name="GameServer" dir=in action=allow protocol=TCP localport=9100

# Linux
sudo ufw allow 9100/tcp
```

4. **检查 WebSocket 路径**
```javascript
// 正确
ws://127.0.0.1:9100/game

// 错误
ws://127.0.0.1:9100/doudizhu  // 旧版路径
ws://127.0.0.1:9100           // 缺少路径
```

### 1.2 连接后立即断开

**症状：**
```
连接成功 → 1 秒后断开
```

**可能原因：**
1. 未发送 LOGIN 命令
2. Token 无效
3. 服务端异常

**解决方案：**
```javascript
ws.onopen = () => {
  // 必须立即发送 LOGIN
  ws.send(JSON.stringify({
    cmd: 1,
    data: { token: 'xxx' }
  }))
}

ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.cmd === 1 && msg.code !== 0) {
    console.error('登录失败:', msg.msg)
    // 检查 token 是否有效
  }
}
```

## 2. Token 问题

### 2.1 Token 无效 (code=5)

**症状：**
```json
{
  "cmd": 1,
  "code": 5,
  "msg": "token invalid"
}
```

**可能原因：**
1. Token 过期（5 分钟有效期）
2. Token 已使用（一次性）
3. Token 格式错误

**解决方案：**

1. **检查 token 获取时间**
```javascript
const tokenTime = Date.now()
// ...
const elapsed = Date.now() - tokenTime
if (elapsed > 5 * 60 * 1000) {
  console.warn('Token 可能已过期，重新获取')
  // 重新调用 /enter_private_room
}
```

2. **不要重复使用 token**
```javascript
// ❌ 错误
const token = 'xxx'
ws1.send({cmd: 1, data: {token}})
ws2.send({cmd: 1, data: {token}})  // 第二次会失败

// ✅ 正确
// 每次连接都重新获取 token
```

3. **检查 token 格式**
```javascript
// Token 应该是 Base64 字符串
console.log('Token:', token)
console.log('Length:', token.length)
// 正常应该是 100+ 字符
```

### 2.2 Token 过期处理

**最佳实践：**
```javascript
class TokenManager {
  constructor() {
    this.token = null
    this.tokenTime = 0
  }
  
  async getToken(userId, roomId) {
    // 检查是否过期（提前 30 秒刷新）
    if (this.token && Date.now() - this.tokenTime < 4.5 * 60 * 1000) {
      return this.token
    }
    
    // 重新获取
    const resp = await fetch(
      `/enter_private_room?userId=${userId}&roomid=${roomId}&name=xxx`
    )
    const result = await resp.json()
    this.token = result.data.token
    this.tokenTime = Date.now()
    return this.token
  }
}
```

## 3. 匹配问题

### 3.1 匹配超时

**症状：**
```
调用 /match/start → 一直返回 {status: "matching"} → 30 秒后超时
```

**可能原因：**
1. 玩家不足（需要 3 人，只有 2 人在线）
2. 服务器定时任务未运行
3. Redis 连接失败（集群模式）

**排查步骤：**

1. **检查匹配队列**
```bash
# Redis 命令
redis-cli
> LLEN hall:match:queue:doudizhu:1
> LRANGE hall:match:queue:doudizhu:1 0 -1
```

2. **检查服务器日志**
```bash
# 查找匹配相关日志
tail -f logs/hall-server.log | grep -i match
```

3. **检查定时任务**
```java
// HallServer.java
private void startScheduler() {
    scheduler.scheduleAtFixedRate(
        matchService::processMatch,
        1, 1, TimeUnit.SECONDS  // 确认定时任务正在运行
    );
}
```

**解决方案：**

1. **使用快速开始代替匹配**
```javascript
// 快速开始不需要等待
const result = await fetch('/quick_start?...')
// 立即返回房间信息
```

2. **增加超时时间**
```javascript
const MATCH_TIMEOUT = 60000  // 60 秒
```

3. **添加机器人**
```bash
# 启动机器人客户端
cd robot
mvn exec:java -Dexec.mainClass=game.robot.RobotClient
```

### 3.2 匹配成功但连接失败

**症状：**
```
/match/start → {status: "matched", ip, port, token}
→ WebSocket 连接失败
```

**可能原因：**
1. GameServer 未启动
2. IP/端口配置错误（Docker 环境）
3. 防火墙阻止

**排查步骤：**

1. **检查返回的 IP 和端口**
```javascript
console.log('GameServer:', result.data.ip, result.data.port)
// 确认是否可访问
```

2. **测试连接**
```bash
# Windows
telnet 127.0.0.1 9100

# Linux/Mac
nc -zv 127.0.0.1 9100
```

3. **检查 GameServer 配置**
```yaml
# config.yml
server:
  # Docker 环境需要配置外部地址
  advertiseHost: ${ADVERTISE_HOST:127.0.0.1}
  advertiseWsPort: ${ADVERTISE_WS_PORT:9100}
```

## 4. 断线重连问题

### 4.1 断线后无法重连

**症状：**
```
断线 → 调用 /reconnect_info → {hasRoom: false}
```

**可能原因：**
1. 快照已过期（默认 1 小时）
2. 服务器重启，快照丢失
3. 游戏已结束

**解决方案：**

1. **检查快照是否存在**
```bash
# Redis
redis-cli
> GET snapshot:user:10001
```

2. **增加快照有效期**
```java
// GameServer.java
RoomSnapshot.save(userId, serverId, roomId, gameType, seatIndex, 
    7200);  // 2 小时
```

3. **快照丢失时的处理**
```javascript
const reconnectInfo = await checkReconnect()
if (!reconnectInfo || !reconnectInfo.hasRoom) {
  console.log('无断线房间，返回大厅')
  showLobby()
  return
}
```

### 4.2 重连后游戏状态不对

**症状：**
```
重连成功 → 但手牌、游戏状态不正确
```

**可能原因：**
1. `getGameState()` 未正确实现
2. 客户端未正确处理 `game` 字段

**解决方案：**

1. **检查服务端实现**
```java
@Override
protected Object getGameState(RoomMgr.Room<G> room, int seatIndex) {
    if (room.game == null) return null;
    
    DoudizhuGame game = room.game;
    DdzStateVO vo = new DdzStateVO();
    vo.status = game.status;
    vo.currentSeat = game.currentSeat;
    vo.myCards = game.getPlayerCards(seatIndex);  // 确保返回正确的手牌
    // ...
    return vo;
}
```

2. **检查客户端处理**
```javascript
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.cmd === 1 && msg.code === 0) {
    const { roomId, seatIndex, seats, game } = msg.data
    
    if (game) {
      // 断线重连，恢复游戏状态
      console.log('恢复游戏状态:', game)
      this.restoreGameState(game)
    }
  }
}
```

## 5. 游戏操作问题

### 5.1 操作无响应

**症状：**
```
发送出牌命令 → 无任何响应
```

**可能原因：**
1. 不是你的回合
2. 命令格式错误
3. WebSocket 连接已断开

**排查步骤：**

1. **检查是否轮到你**
```javascript
// 等待 TURN 消息
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.cmd === 522) {  // TURN
    if (msg.data.seatIndex === mySeatIndex) {
      console.log('轮到我了')
      enablePlayButton()
    }
  }
}
```

2. **检查命令格式**
```javascript
// ✅ 正确
ws.send(JSON.stringify({
  cmd: 1003,
  data: {
    cards: [3, 4, 5, 6, 7]
  }
}))

// ❌ 错误
ws.send(JSON.stringify({
  cmd: 1003,
  cards: [3, 4, 5, 6, 7]  // data 字段缺失
}))
```

3. **检查连接状态**
```javascript
if (ws.readyState !== WebSocket.OPEN) {
  console.error('WebSocket 未连接')
  reconnect()
}
```

### 5.2 操作被拒绝 (code != 0)

**症状：**
```json
{
  "cmd": 1003,
  "code": 11,
  "msg": "cannot beat"
}
```

**常见错误码：**

| code | 说明 | 解决方案 |
|------|------|----------|
| 6 | 不是你的回合 | 等待 TURN 消息 |
| 10 | 无效的牌 | 检查牌是否在手中 |
| 11 | 打不过 | 选择更大的牌型 |
| 12 | 不能不出 | 必须出牌（首轮） |

**处理建议：**
```javascript
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.code !== 0) {
    switch (msg.code) {
      case 6:
        showTip('还没轮到你')
        break
      case 11:
        showTip('打不过，请选择更大的牌')
        break
      default:
        showTip(msg.msg || '操作失败')
    }
  }
}
```

## 6. 性能问题

### 6.1 消息延迟高

**症状：**
```
发送消息 → 2-3 秒后才收到响应
```

**可能原因：**
1. 网络延迟
2. 服务器负载高
3. 客户端处理慢

**排查步骤：**

1. **测量网络延迟**
```javascript
const start = Date.now()
ws.send(JSON.stringify({cmd: 4}))  // PING

ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.cmd === 4) {
    const latency = Date.now() - start
    console.log('延迟:', latency, 'ms')
  }
}
```

2. **检查服务器负载**
```bash
# 查看 CPU 和内存
top

# 查看 Java 进程
jps -lvm
```

3. **优化客户端处理**
```javascript
// ❌ 慢
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  updateUI(msg)  // 同步更新 UI，阻塞消息处理
}

// ✅ 快
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  setTimeout(() => updateUI(msg), 0)  // 异步更新 UI
}
```

### 6.2 内存泄漏

**症状：**
```
长时间运行 → 内存占用持续增长 → 最终崩溃
```

**常见原因：**
1. WebSocket 未关闭
2. 定时器未清理
3. 事件监听器未移除

**解决方案：**

1. **正确关闭 WebSocket**
```javascript
class GameClient {
  disconnect() {
    if (this.ws) {
      this.ws.onclose = null  // 移除监听器
      this.ws.close()
      this.ws = null
    }
  }
}
```

2. **清理定时器**
```javascript
class GameClient {
  startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      this.send(4, {})
    }, 30000)
  }
  
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }
}
```

3. **使用 WeakMap**
```javascript
// ❌ 可能泄漏
const userCache = new Map()
userCache.set(userId, userData)

// ✅ 自动回收
const userCache = new WeakMap()
userCache.set(userObject, userData)
```

## 7. 调试技巧

### 7.1 启用详细日志

**客户端：**
```javascript
const DEBUG = true

function log(...args) {
  if (DEBUG) {
    console.log('[GameClient]', ...args)
  }
}

ws.onmessage = (e) => {
  log('收到消息:', e.data)
  // ...
}

ws.send = (data) => {
  log('发送消息:', data)
  WebSocket.prototype.send.call(ws, data)
}
```

**服务端：**
```yaml
# config.yml
logging:
  level: DEBUG
```

### 7.2 使用 Chrome DevTools

1. **Network 面板**
   - 查看 WebSocket 连接
   - 查看消息收发记录

2. **Console 面板**
   - 手动发送测试消息
   ```javascript
   ws.send(JSON.stringify({cmd: 4}))
   ```

3. **Application 面板**
   - 查看 LocalStorage
   - 查看 SessionStorage

### 7.3 使用 Postman 测试 HTTP API

```
# 测试登录
POST http://localhost:8101/auth/login
Body: {"username": "test", "password": "123456"}

# 测试快速开始
GET http://localhost:8201/quick_start?userId=10001&gameType=doudizhu&level=1&name=test
```

### 7.4 使用 wscat 测试 WebSocket

```bash
# 安装
npm install -g wscat

# 连接
wscat -c ws://localhost:9100/game

# 发送消息
> {"cmd":1,"data":{"token":"xxx"}}

# 查看响应
< {"cmd":1,"code":0,"data":{...}}
```

## 8. 生产环境问题

### 8.1 Docker 环境连接失败

**问题：**
```
容器内服务正常 → 外部无法连接
```

**解决方案：**

1. **配置外部地址**
```yaml
# docker-compose.yml
services:
  game-server:
    environment:
      - ADVERTISE_HOST=192.168.1.100  # 宿主机 IP
      - ADVERTISE_WS_PORT=30100       # NodePort
```

2. **端口映射**
```yaml
ports:
  - "30100:9100"  # 外部:内部
  - "30101:9101"
```

### 8.2 Nginx 代理问题

**问题：**
```
HTTP 正常 → WebSocket 502 Bad Gateway
```

**解决方案：**

```nginx
# nginx.conf
location /ws/ {
    proxy_pass http://game-servers;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_read_timeout 3600s;  # 增加超时
}
```

## 9. 紧急恢复

### 9.1 服务器崩溃

**步骤：**
1. 重启服务
2. 检查日志找出原因
3. 通知玩家重新登录

```bash
# 重启
./stop-all.cmd
./start-all.cmd

# 查看日志
tail -f logs/*.log
```

### 9.2 数据丢失

**Redis 数据丢失：**
```bash
# 检查 Redis 持久化
redis-cli
> CONFIG GET save
> CONFIG GET appendonly

# 启用持久化
> CONFIG SET save "900 1 300 10 60 10000"
> CONFIG SET appendonly yes
```

**MySQL 数据丢失：**
```bash
# 恢复备份
mysql -u root -p game < backup.sql
```

## 10. 联系支持

如果以上方法都无法解决问题，请提供以下信息：

1. **问题描述**
   - 具体症状
   - 复现步骤
   - 预期行为 vs 实际行为

2. **环境信息**
   - 操作系统
   - Java 版本
   - 浏览器版本（客户端）

3. **日志**
   - 服务端日志
   - 浏览器 Console 日志
   - 网络请求记录

4. **配置文件**
   - config.yml
   - application.properties

提交 Issue: https://github.com/xxx/room-game/issues
