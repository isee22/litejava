# 游戏流程问题分析与改进方案

## 已完成的改进

### 1. 签名验证 (BabyKylin 模式)

**HallServer 返回 time + sign：**
```java
// ClientService.java - 所有房间操作返回签名
vo.time = System.currentTimeMillis();
vo.sign = sign.sign(roomId, token, time);  // md5(roomid + token + time + priKey)
```

**GameServer 验证签名：**
```java
// GameServer.java - onLogin 断言方式验证
String expectedSign = md5(roomId + token + time + roomPriKey);
if (!expectedSign.equals(sign)) {
    sendError(session, 2, "sign check failed");
    return;
}
```

### 2. 断线重连 (登录时返回 roomId)

**AccountServer 登录响应：**
```java
// LoginResp.java
public String roomId;      // 如果在房间中，返回房间号
public String serverId;    // GameServer ID

// AuthController.java
Services.reconnect.fillReconnectInfo(resp);
```

**ReconnectService 从 Redis 读取：**
```java
// 读取 HallServer 写入的用户房间信息
String roomId = Cache.instance.get("hall:user:" + userId);
String serverId = Cache.instance.get("hall:room:" + roomId);
```

### 3. 错误响应格式 (BabyKylin 兼容)

**GameServer 错误响应：**
```java
// sendError 方法 - BabyKylin 格式
{cmd: 1, errcode: 2, errmsg: "sign check failed"}
```

**错误码对照：**
| errcode | 说明 |
|---------|------|
| 1 | invalid parameters |
| 2 | sign check failed |
| 3 | token out of time |

---

## 问题概述

对比 BabyKylin-SCMJ（Node.js 示例项目）和 room-game（Java 实现），发现 Java 版本在实现时偏离了 BabyKylin 的原始设计，导致流程不一致和对接困难。

## BabyKylin 原始流程（正确参考）

### 完整流程
```
1. 客户端 → AccountServer: GET /login?account=xxx&sign=xxx
   ← {userid, name, coins, roomid?}  // roomid 用于断线重连

2. 客户端 → HallServer: GET /create_private_room?account=xxx&conf=xxx&sign=xxx
   ← {roomid, ip, port, token, time, sign}

3. 客户端 → GameServer WebSocket: ws://ip:port
   发送: {event: "login", data: {token, roomid, time, sign}}
   ← {event: "login_result", data: {roomid, conf, seats, ...}}
   ← {event: "login_finished"}  // 触发场景切换

4. 游戏中通信: socket.emit('ready'), socket.emit('chupai', pai)
```

### 关键特征
1. **签名验证贯穿全流程** - 每个接口都有 sign 参数
2. **Socket.IO 事件驱动** - 使用命名事件（login, ready, chupai）而非 cmd 数字
3. **分步登录** - login_result + login_finished 两步确认
4. **断线重连信息在登录时返回** - roomid 字段直接告知客户端

## 核心问题清单

### 1. 【严重】WebSocket 协议完全不同

**BabyKylin 原始实现（Socket.IO）：**
```javascript
// 客户端
socket.emit('login', {token, roomid, time, sign})
socket.on('login_result', (data) => { ... })
socket.on('login_finished', () => { ... })
socket.emit('ready')
socket.emit('chupai', pai)

// 服务端
socket.on('login', function(data) { ... })
socket.emit('login_result', ret)
socket.emit('login_finished')
```

**room-game Java 实现（自定义协议）：**
```java
// 客户端
ws.send(JSON.stringify({cmd: 1, data: {token}}))
ws.onmessage = (e) => {
  const msg = JSON.parse(e.data)
  if (msg.cmd === 1) { ... }
}

// 服务端
{cmd: 1, code: 0, data: {...}}
```

**问题：**
- 协议格式完全不兼容
- BabyKylin 用事件名（字符串），Java 用 cmd 号（数字）
- BabyKylin 分两步确认（login_result + login_finished），Java 一步完成

**改进方案：**
Java 版本应该：
1. 使用 Socket.IO 库或兼容 Socket.IO 协议
2. 或者在文档中明确说明"Java 版本使用了不同的协议"
3. 提供协议转换对照表

### 2. 【严重】签名验证流程缺失

**BabyKylin 原始实现：**
```javascript
// HallServer 返回
{
  roomid: "123456",
  ip: "127.0.0.1",
  port: 10000,
  token: "xxx",
  time: Date.now(),
  sign: md5(roomid + token + time + ROOM_PRI_KEY)
}

// 客户端连接 GameServer 时必须带上所有参数
socket.emit('login', {
  token: data.token,
  roomid: data.roomid,
  time: data.time,
  sign: data.sign  // 必须！
})

// GameServer 验证
var md5 = crypto.md5(roomId + token + time + config.ROOM_PRI_KEY);
if(md5 != sign){
  socket.emit('login_result',{errcode:2,errmsg:"invalid sign!"});
  return;
}
```

**room-game Java 实现：**
```java
// HallServer 返回（缺少 time 和 sign）
{
  "roomId": "123456",
  "ip": "127.0.0.1",
  "port": 9100,
  "token": "xxx"
}

// 客户端只需要 token
ws.send(JSON.stringify({cmd: 1, data: {token}}))

// GameServer 只验证 token
TokenManager.TokenInfo tokenInfo = TokenManager.parse(token);
```

**问题：**
- Java 版本完全移除了签名验证机制
- 安全性大幅降低
- 与 BabyKylin 原始设计不一致

**改进方案：**
```java
// HallServer 返回时添加签名
Map<String, Object> ret = Map.of(
    "roomId", roomId,
    "ip", serverInfo.clientip,
    "port", serverInfo.clientport,
    "token", token,
    "time", System.currentTimeMillis()
);
String sign = SignUtil.md5(roomId + token + ret.get("time") + roomPriKey);
ret.put("sign", sign);

// GameServer 验证签名
private void onLogin(WsSession session, Map<String, Object> data) {
    String token = (String) data.get("token");
    String roomId = (String) data.get("roomId");
    Long time = (Long) data.get("time");
    String sign = (String) data.get("sign");
    
    // 验证签名
    String expectedSign = SignUtil.md5(roomId + token + time + roomPriKey);
    if (!expectedSign.equals(sign)) {
        send(session, Cmd.LOGIN, ErrCode.INVALID_SIGN, null);
        return;
    }
    
    // 验证时间戳（防重放攻击）
    if (System.currentTimeMillis() - time > 300000) { // 5分钟
        send(session, Cmd.LOGIN, ErrCode.TOKEN_EXPIRED, null);
        return;
    }
}
    
    // 验证 token
    // ...
}
```

### 3. 登录响应分步确认

**BabyKylin 原始实现：**
```javascript
// GameServer 分两步确认
socket.emit('login_result', {
  errcode: 0,
  data: {roomid, conf, seats, ...}
})
socket.emit('login_finished')  // 触发场景切换

// 客户端
cc.vv.net.addHandler("login_result", function(data){
  // 初始化房间数据
  self.roomId = data.data.roomid
  self.seats = data.data.seats
  self.dispatchEvent('login_result')
})

cc.vv.net.addHandler("login_finished", function(data){
  // 切换到游戏场景
  cc.director.loadScene("mjgame", function(){
    cc.vv.wc.hide()
  })
})
```

**room-game Java 实现：**
```java
// 一步完成
send(session, Cmd.LOGIN, vo)
```

**说明：**
- `login_finished` 是客户端自己的事件，服务端不需要发
- 客户端收到 LOGIN 响应后自己触发 `login_finished` 切换场景即可

### 4. 【中等】断线重连信息获取方式不同

**BabyKylin 原始实现：**
```javascript
// 登录时直接返回 roomid
app.get('/login', function(req,res){
  db.get_user_data(account, function(data){
    var ret = {
      userid: data.userid,
      name: data.name,
      coins: data.coins
    }
    
    // 检查是否在房间中
    db.get_room_id_of_user(data.userid, function(roomId){
      if(roomId != null){
        ret.roomid = roomId  // 直接返回！
      }
      http.send(res, 0, "ok", ret)
    })
  })
})

// 客户端
if (loginResult.roomid) {
  // 有断线房间，直接重连
  reconnectToRoom(loginResult.roomid)
}
```

**room-game Java 实现：**
```java
// 需要单独调用接口
GET /reconnect_info?userId=xxx
```

**问题：**
- 增加了一次 HTTP 请求
- 与 BabyKylin 原始设计不一致

**改进方案：**
```java
// AccountServer 登录接口返回 roomId
app.post("/auth/login", ctx -> {
    // ... 验证用户
    
    Map<String, Object> result = Map.of(
        "userId", user.userId,
        "name", user.name,
        "coins", user.coins
    );
    
    // 检查断线重连
    RoomSnapshot.Info snapshot = RoomSnapshot.get(user.userId);
    if (snapshot != null) {
        result.put("roomId", snapshot.roomId);
        result.put("serverId", snapshot.serverId);
        result.put("gameType", snapshot.gameType);
    }
    
    ctx.ok(result);
})
```

### 5. 快速开始流程 ✅ 已简化

**BabyKylin 原始实现：**
- 只有 `/create_private_room` 和 `/enter_private_room`
- 没有"快速开始"和"匹配队列"的概念
- 简单直接：创建房间 → 分享房间号 → 朋友加入

**room-game Java 实现：**
- 保留 `/quick_start`（有房间就加入，没房间就创建）
- 删除了 `MatchService`（MOBA 类型游戏用，当前场景不需要）
- 保持简单：创建房间 / 加入房间 / 快速开始

### 6. 【中等】游戏事件命名不一致

**BabyKylin 原始实现（Socket.IO 事件）：**
```javascript
// 客户端发送
socket.emit('ready')
socket.emit('chupai', pai)
socket.emit('peng')
socket.emit('gang', pai)
socket.emit('hu')
socket.emit('guo')

// 服务端推送
socket.emit('game_holds_push', data)
socket.emit('game_begin_push', data)
socket.emit('game_chupai_push', userId)
socket.emit('peng_notify_push', data)
socket.emit('gang_notify_push', data)
socket.emit('hu_push', data)
```

**room-game Java 实现（CMD 数字）：**
```java
// 客户端发送
{cmd: 504}  // READY
{cmd: 1201} // DISCARD (出牌)
{cmd: 1203} // PENG
{cmd: 1204} // GANG
{cmd: 1205} // HU

// 服务端推送
{cmd: 520}  // DEAL
{cmd: 522}  // TURN
{cmd: 511}  // GAME_OVER
```

**问题：**
- 事件命名完全不同
- BabyKylin 客户端无法直接对接 Java 服务端

**改进方案：**
```java
// 方案 A：提供 Socket.IO 适配层
public class SocketIOAdapter {
    private Map<String, Integer> eventToCmdMap = Map.of(
        "ready", 504,
        "chupai", 1201,
        "peng", 1203,
        "gang", 1204,
        "hu", 1205
    );
    
    public int getCmd(String event) {
        return eventToCmdMap.getOrDefault(event, -1);
    }
}

// 方案 B：文档中提供完整的事件对照表
```

### 7. 【中等】房间配置格式不同

**BabyKylin 原始实现：**
```javascript
// 配置是 JSON 字符串
conf: "{\"maxGames\":8,\"maxFan\":3,\"hsz\":true}"

// 服务端解析
conf = JSON.parse(conf)
```

**room-game Java 实现：**
```java
// 配置是 JSON 对象
conf: {"maxPlayers": 3, "level": 1}
```

**问题：**
- 格式不一致
- 配置字段名不同（maxGames vs maxPlayers）

**改进方案：**
统一配置格式，兼容两种方式：
```java
String confStr = ctx.queryParam("conf");
Map<String, Object> conf;
if (confStr.startsWith("{")) {
    conf = app.json.parseMap(confStr);
} else {
    // 兼容旧格式
    conf = Map.of("maxPlayers", 3);
}
```

### 8. 【轻微】心跳机制命名不同

**BabyKylin 原始实现：**
```javascript
socket.emit('game_ping')
socket.on('game_pong', () => {})
```

**room-game Java 实现：**
```java
{cmd: 4}  // PING
{cmd: 4, code: 0}  // PONG
```

**改进方案：**
文档中说明差异即可。

### 9. 【严重】错误响应格式不同

**BabyKylin 原始实现：**
```javascript
// HTTP 响应
{errcode: 0, errmsg: "ok", data: {...}}
{errcode: 1, errmsg: "error message"}

// WebSocket 响应
{errcode: 0, errmsg: "ok", data: {...}}
{errcode: 2, errmsg: "sign check failed"}
```

**room-game Java 实现：**
```java
// HTTP 响应
{code: 0, data: {...}}
{code: 1, msg: "error message"}

// WebSocket 响应
{cmd: 1, code: 0, data: {...}}
{cmd: 1, code: 5, msg: "error message"}
```

**问题：**
- 字段名不一致：errcode vs code, errmsg vs msg
- BabyKylin 客户端需要修改才能对接

**改进方案：**
```java
// 统一使用 BabyKylin 格式
public class Response {
    public int errcode;
    public String errmsg;
    public Object data;
    
    public static Response ok(Object data) {
        Response r = new Response();
        r.errcode = 0;
        r.errmsg = "ok";
        r.data = data;
        return r;
    }
    
    public static Response fail(int code, String msg) {
        Response r = new Response();
        r.errcode = code;
        r.errmsg = msg;
        return r;
    }
}
```

### 10. 【中等】服务注册参数不同

**BabyKylin 原始实现：**
```javascript
// GameServer 注册到 HallServer
{
  clientip: "127.0.0.1",
  clientport: 10000,
  httpPort: 9003,
  load: 5
}
```

**room-game Java 实现：**
```java
// GameServer 注册
{
  id: "127.0.0.1:9100",
  clientip: "127.0.0.1",
  clientport: 9100,
  httpPort: 9101,
  load: 5
}
```

**问题：**
- 参数名基本一致，但 Java 版本多了 id 字段
- 影响不大

## 流程对比图

### BabyKylin 原始流程（正确）

```
客户端                    AccountServer           HallServer              GameServer
  │                          │                        │                        │
  │ 1. GET /login           │                        │                        │
  │    ?account=xxx&sign=xxx│                        │                        │
  │───────────────────────►│                        │                        │
  │   {userid, name, coins, │                        │                        │
  │    roomid?}             │                        │                        │
  │◄───────────────────────│                        │                        │
  │                          │                        │                        │
  │ 2. GET /create_private_room                      │                        │
  │    ?account=xxx&conf=xxx&sign=xxx                │                        │
  │──────────────────────────────────────────────────►│                        │
  │                          │                        │ 3. 选择 GameServer     │
  │                          │                        │ 4. POST /create_room   │
  │                          │                        │───────────────────────►│
  │                          │                        │◄───────────────────────│
  │                          │                        │ 5. POST /enter_room    │
  │                          │                        │───────────────────────►│
  │   {roomid, ip, port,     │                        │◄───────────────────────│
  │    token, time, sign}    │                        │                        │
  │◄──────────────────────────────────────────────────│                        │
  │                          │                        │                        │
  │ 6. WebSocket ws://ip:port                         │                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │ 7. emit('login', {token, roomid, time, sign})     │                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │   on('login_result', {roomid, seats, ...})        │                        │
  │◄───────────────────────────────────────────────────────────────────────────│
  │   on('login_finished')                            │                        │
  │◄───────────────────────────────────────────────────────────────────────────│
  │                          │                        │                        │
  │ 8. emit('ready')                                  │                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │   on('user_ready_push', {userid, ready})          │                        │
  │◄───────────────────────────────────────────────────────────────────────────│
```

### room-game Java 实现（有差异）

```
客户端                    AccountServer           HallServer              GameServer
  │                          │                        │                        │
  │ 1. POST /auth/login     │                        │                        │
  │    {username, password} │                        │                        │
  │───────────────────────►│                        │                        │
  │   {userId, name, coins} │                        │                        │
  │◄───────────────────────│                        │                        │
  │                          │                        │                        │
  │ 2. GET /quick_start (新增)                       │                        │
  │    ?userId=xxx&gameType=xxx                      │                        │
  │──────────────────────────────────────────────────►│                        │
  │   {roomId, ip, port, token} (无 time, sign)      │                        │
  │◄──────────────────────────────────────────────────│                        │
  │                          │                        │                        │
  │ 3. WebSocket ws://ip:port/game                    │                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │ 4. {cmd: 1, data: {token}} (无 roomid, time, sign)│                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │   {cmd: 1, code: 0, data: {roomId, seats, ...}}   │                        │
  │◄───────────────────────────────────────────────────────────────────────────│
  │   (无 login_finished)                             │                        │
  │                          │                        │                        │
  │ 5. {cmd: 504}                                     │                        │
  │───────────────────────────────────────────────────────────────────────────►│
  │   {cmd: 504, code: 0, data: {userId, ready}}      │                        │
  │◄───────────────────────────────────────────────────────────────────────────│
```

## 改进优先级

### P0（必须修复 - 协议兼容性）✅ 已完成
1. ✅ 添加签名验证机制（time + sign）
2. ✅ 统一错误响应格式（errcode + errmsg）
3. ✅ 登录时返回 roomid（断线重连）

### P1（强烈建议 - 流程一致性）✅ 已完成
4. ✅ 添加 login_finished 事件（客户端自己处理，服务端不需要发）
5. ✅ 提供 Socket.IO 事件对照表
6. ✅ 统一房间配置格式

### P2（可选 - 功能扩展）
7. ✅ 删除 MatchService（MOBA 类型游戏用，当前场景不需要）
8. ✅ 文档中明确说明与 BabyKylin 的差异
9. 提供协议转换工具（可选）

## 建议的改进方案

### 方案 A：完全兼容 BabyKylin（推荐）

1. **修改 HallServer 响应格式**
```java
Map<String, Object> ret = Map.of(
    "roomid", roomId,  // 使用 roomid 而非 roomId
    "ip", serverInfo.clientip,
    "port", serverInfo.clientport,
    "token", token,
    "time", System.currentTimeMillis(),
    "sign", SignUtil.md5(roomId + token + time + roomPriKey)
);
```

2. **修改 GameServer WebSocket 登录**
```java
private void onLogin(WsSession session, Map<String, Object> data) {
    String token = (String) data.get("token");
    String roomId = (String) data.get("roomid");  // 注意小写
    Long time = (Long) data.get("time");
    String sign = (String) data.get("sign");
    
    // 验证签名
    String expectedSign = SignUtil.md5(roomId + token + time + roomPriKey);
    if (!expectedSign.equals(sign)) {
        sendError(session, 2, "sign check failed");
        return;
    }
    
    // 验证 token
    // ...
    
    // 发送 login_result
    sendEvent(session, "login_result", Map.of(
        "errcode", 0,
        "errmsg", "ok",
        "data", roomData
    ));
    
    // 延迟发送 login_finished
    scheduler.schedule(() -> {
        sendEvent(session, "login_finished", null);
    }, 100, TimeUnit.MILLISECONDS);
}
```

3. **统一错误响应格式**
```java
public class BabyKylinResponse {
    public int errcode;
    public String errmsg;
    public Object data;
}
```

### 方案 B：保持现状 + 完善文档

如果不想修改代码，至少要：

1. **创建协议对照表**
```markdown
| BabyKylin (Socket.IO) | room-game (Java) | 说明 |
|----------------------|------------------|------|
| emit('login', {token, roomid, time, sign}) | {cmd: 1, data: {token}} | 登录 |
| on('login_result') | {cmd: 1, code: 0} | 登录响应 |
| on('login_finished') | (无) | 场景切换信号 |
| emit('ready') | {cmd: 504} | 准备 |
| on('user_ready_push') | {cmd: 504, code: 0} | 准备广播 |
```

2. **明确说明差异**
```markdown
# Java 版本与 BabyKylin 的差异

## 协议格式
- BabyKylin 使用 Socket.IO 事件驱动
- Java 版本使用自定义 CMD 协议

## 签名验证
- BabyKylin 每个请求都有签名
- Java 版本简化了签名流程

## 断线重连
- BabyKylin 登录时返回 roomid
- Java 版本需要调用 /reconnect_info
```

## 总结

核心改进已完成：

1. ✅ **签名验证** - HallServer 返回 time + sign，GameServer 验证签名
2. ✅ **断线重连** - AccountServer 登录时返回 roomId
3. ✅ **错误响应** - 使用 errcode/errmsg 格式
4. ✅ **代码精简** - 删除了 MatchService、HallException、AccountException

剩余差异（协议格式）是设计选择，不影响功能：
- BabyKylin 使用 Socket.IO 事件驱动
- Java 版本使用 CMD 数字协议（更通用）
